<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sports Club Fixtures & Results</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="gms-wrapper gms-ajax" 
         data-method="api" 
         data-show="results" 
         data-club_id="e9ba26d3-7e18-4772-abb0-584e887c9d38" 
         data-whatson="7" 
         data-sort_by="fixtureTime" 
         data-options="showGender:yes,showList:yes"
         data-css="no">
    </div>
    
    <script src="https://gmsfeed.co.uk/js/api.js"></script>
    <script>
        // Text Parser for GMS API Content
        function parseGMSContent() {
            const wrapper = document.querySelector('.gms-wrapper');
            if (!wrapper || !wrapper.textContent) return;
            
            const rawText = wrapper.textContent.trim();
            const lines = rawText.split('\n').filter(line => line.trim());
            
            // Clear existing content
            wrapper.innerHTML = '';
            wrapper.style.fontSize = '14px';
            wrapper.style.color = '#333';
            
            // Group matches by date
            const matchGroups = {};
            let currentMatch = {};
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Date line (e.g., "20 SEP 2025")
                if (line.match(/^\d{1,2} [A-Z]{3} \d{4}$/)) {
                    if (currentMatch.date) {
                        // Save previous match
                        const date = currentMatch.date;
                        if (!matchGroups[date]) matchGroups[date] = [];
                        matchGroups[date].push(currentMatch);
                    }
                    currentMatch = { date: line };
                }
                // Team name (e.g., "CHELMSFORD 5 (F)")
                else if (line.match(/^[A-Z][A-Z\s\d()]+$/) && !line.includes(':')) {
                    if (currentMatch.team1) {
                        currentMatch.team2 = line;
                    } else {
                        currentMatch.team1 = line;
                    }
                }
                // Score (e.g., "2 : 1")
                else if (line.match(/^\d+ : \d+$/)) {
                    const [score1, score2] = line.split(' : ');
                    currentMatch.score1 = score1;
                    currentMatch.score2 = score2;
                }
                // Venue or other info
                else if (line.length > 0 && !line.match(/^\d+ : \d+$/)) {
                    if (!currentMatch.venue) {
                        currentMatch.venue = line;
                    }
                }
            }
            
            // Add the last match
            if (currentMatch.date) {
                const date = currentMatch.date;
                if (!matchGroups[date]) matchGroups[date] = [];
                matchGroups[date].push(currentMatch);
            }
            
            // Create HTML structure
            Object.keys(matchGroups).forEach(date => {
                const section = document.createElement('div');
                section.className = 'tournament-section';
                
                // Header
                const header = document.createElement('div');
                header.className = 'tournament-header';
                header.innerHTML = `
                    FIXTURES & RESULTS
                    <div class="tournament-date">${formatDate(date)}</div>
                `;
                section.appendChild(header);
                
                // Matches
                matchGroups[date].forEach((match, index) => {
                    if (match.team1 && match.team2 && match.score1 !== undefined) {
                        // Team 1 row
                        const row1 = createMatchRow(match.team1, match.score1, index * 2);
                        section.appendChild(row1);
                        
                        // Team 2 row
                        const row2 = createMatchRow(match.team2, match.score2, index * 2 + 1);
                        section.appendChild(row2);
                        
                        // Venue link if available
                        if (match.venue) {
                            const venueLink = document.createElement('a');
                            venueLink.className = 'venue-link';
                            venueLink.href = '#';
                            venueLink.textContent = match.venue;
                            section.appendChild(venueLink);
                        }
                    }
                });
                
                wrapper.appendChild(section);
            });
        }

        function createMatchRow(teamName, score, colorIndex) {
            const row = document.createElement('div');
            row.className = 'match-row';
            
            const logoColors = ['', 'alt-1', 'alt-2', 'alt-3'];
            const colorClass = logoColors[colorIndex % logoColors.length];
            
            row.innerHTML = `
                <div class="team-logo ${colorClass}"></div>
                <div class="team-names">${teamName}</div>
                <div class="match-score">${score}</div>
                <div class="chevron">â€º</div>
            `;
            
            return row;
        }

        function formatDate(dateStr) {
            const parts = dateStr.split(' ');
            const months = {
                'JAN': 'Jan', 'FEB': 'Feb', 'MAR': 'Mar', 'APR': 'Apr',
                'MAY': 'May', 'JUN': 'Jun', 'JUL': 'Jul', 'AUG': 'Aug',
                'SEP': 'Sep', 'OCT': 'Oct', 'NOV': 'Nov', 'DEC': 'Dec'
            };
            return `${parts[0]} ${months[parts[1]] || parts[1]}`;
        }

        // Wait for the API to load content, then parse it
        function waitAndParse() {
            const wrapper = document.querySelector('.gms-wrapper');
            if (wrapper && wrapper.textContent && wrapper.textContent.trim()) {
                parseGMSContent();
            } else {
                setTimeout(waitAndParse, 500);
            }
        }

        // Start checking after a short delay
        setTimeout(waitAndParse, 1000);
    </script>
</body>
</html>
